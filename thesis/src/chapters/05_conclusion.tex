% !TeX root = ../main.tex
% Add the above to each chapter to make compiling the PDF easier in some editors.

\chapter{Conclusion}\label{ch:conclusion}

\section{Future Work}\label{sec:future-work}

This work has laid the groundwork for an incremental query engine
that can be used to express \acp{CRDT} as Datalog queries.
Many open questions remain.
Differential dataflow.
Non-incremental query processing for hydration use case and then hydrate
incremental operators in the background?

Applying serious query optimization has the potential to improve
the performance of the query engine but this is a challenge in its own right.
Particularly, in the context of \ac{IVM} and transpilation from Datalog to
relational algebra, I want to emphasize two aspects:

\begin{itemize}
	\item \textbf{Join ordering}.
	      As discussed in \ref{sec:ivm}, changing a query plan for a continuously
	      evaluated query can be costly.
	      Also, the query plan has to be chosen upfront and with the absence of
	      statistics about the data.
	      Hence, to what extent is an automated join ordering algorithm useful
	      in this context? Possibly, it may be better to let the query
	      author choose a definitive join order or allow them to provide
	      information about data distributions in case of automated join ordering.
	\item \textbf{Scheduling of antijoins}.
	      Negative atoms are handled with antijoins in the query engine.
	      So far, they are scheduled after the query plan covering the
	      positive atoms.
	      However, antijoins may actually be scheduled better by placing them
	      as early as possible, i.e., if all variables referenced by a
	      negative atom are in scope, to keep the intermediate result set small.
	      This is  because in the worst case, antijoins leave the intermediate
	      result set unchanged but in the average case they filter tuples out.
	      This is similar to predicate pushdown and, therefore, I call this
	      problem \emph{antijoin pushdown}.
\end{itemize}

To minimize the interpretation overhead of the query engine, it could
benefit from some performance engineering.
Tuples are currently represented as vectors and, hence, each tuple access
may cause a cache miss.
Testing different physical data layouts for tuples, e.g., overflow-to-heap
vectors\footnotemark{}, could be an interesting direction to explore.
To further optimize away cache misses, the physical representation of an
\ac{IR} program could be adapted to use a more cache-friendly data layout, too:
Instead of expressions storing references to other expressions in their
input fields, they could be flattened by storing an index into a vector of
expressions, as laid out in~\cite{sampson2023flattening}.
This may improve spatial locality, thereby reducing cache misses, and is
particularly relevant for code that is run at query execution-time because
it is executed frequently (per tuple) instead of just once at query build-time
for creating the query plan.

\footnotetext{
	Overflow-to-heap vectors are vectors that store their elements
	in a contiguous memory region, but if the vector grows beyond a certain
	threshold, it allocates a new memory region on the heap and moves new
	elements there.
	Rust's \href{https://docs.rs/smallvec/latest/smallvec/}{\texttt{smallvec}}
	library implements this concept.
}

Feature-wise, the query engine could be extended to support mutual recursion
and aggregation but I do not consider these features essential for the
\ac{CRDT} use case. On the other hand, native JSON support may be useful for
defining a JSON \ac{CRDT} like Automerge does.
To improve practical usability of the Datalog frontend,
a type checking pass, better error reporting, and supporting tuples as a scalar
type could be added to the query engine.
The latter allows collapsing operations' replica id and counter fields
into a single field, to make Datalog \ac{CRDT} queries more concise.

\ref{sec:crdts-as-queries} defines map and list \acp{CRDT} as queries.
More research is needed to define and benchmark further \acp{CRDT} as queries
before putting this idea into practice.
It is especially important to better understand their performance under various
workloads, e.g., different concurrency patterns, to guide future directions for
optimizing the query engine.
Finally, the question remains if there are \acp{CRDT} that cannot be expressed
with Datalog's restricted expressiveness with stratified negation.
A move operation in replicated trees~\cite{moveop1,moveop2} may be a challenging
candidate, as it requires rolling back updates to a previous state,
applying the move operation, then reapplying the previously undone updates,
and potentially aborting if a cycle is detected.

\section{Outlook}\label{sec:outlook}

Similar to how queries made data retrieval and storage more accessible to
application developers, I hope that expressing \acp{CRDT} as queries
makes \acp{CRDT} and thereby collaborative applications more accessible, too.
